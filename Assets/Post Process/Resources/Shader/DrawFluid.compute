// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Advection //0
#pragma kernel Diffusion1 //1
#pragma kernel Diffusion2 //2
#pragma kernel Force //3
#pragma kernel Divergence //4
#pragma kernel Pressure1 //5
#pragma kernel Pressure2 //6
#pragma kernel Projection  //7
#pragma kernel ClearTexture //8
#pragma kernel MoveDensity //9

RWTexture3D<float4> _Density;
RWTexture3D<float4> _Velocity1;
RWTexture3D<float4> _Velocity2;
RWTexture3D<float4> _Pressure;


float3 _TexDim;
float _Dt;
float _AdvectionSpeed;
float _Viscosity;
float _Gravity;
float3 _ForcePos;
float3 _ForceDir;
float4 _GasColor;

float3 _BlockSpherePos;
float _BlockSphereRadius;

float4 linearInterpolation3D(float3 pos, RWTexture3D<float4> tex)
{
    if (min(pos.x, min(pos.y, pos.z)) < 0 || pos.x >= _TexDim.x || pos.y >= _TexDim.y || pos.z >= _TexDim.z)
    {
        return float4(0, 0, 0, 1);
    }

    // block sphere
    if (distance(pos, _BlockSpherePos) < _BlockSphereRadius)
    {
        return float4(0, 0, 0, 1);
    }

    uint3 texCordFloor = floor(pos);
    uint3 texCordCeil = ceil(pos);
    float3 t = pos - float3(texCordFloor);
    float4 tex000 = tex.Load(texCordFloor);
    float4 tex010 = tex.Load(uint3(texCordFloor.x, texCordCeil.y, texCordFloor.z));
    float4 tex100 = tex.Load(uint3(texCordCeil.x, texCordFloor.y, texCordFloor.z));
    float4 tex110 = tex.Load(uint3(texCordCeil.x, texCordCeil.y, texCordFloor.z));
    float4 tex001 = tex.Load(uint3(texCordFloor.x, texCordFloor.y, texCordCeil.z));
    float4 tex011 = tex.Load(uint3(texCordFloor.x, texCordCeil.y, texCordCeil.z));
    float4 tex101 = tex.Load(uint3(texCordCeil.x, texCordFloor.y, texCordCeil.z));
    float4 tex111 = tex.Load(uint3(texCordCeil.x, texCordCeil.y, texCordCeil.z));
    float4 tex0_0 = lerp(tex000, tex010, t.y);
    float4 tex0_1 = lerp(tex001, tex011, t.y);
    float4 tex1_0 = lerp(tex100, tex110, t.y);
    float4 tex1_1 = lerp(tex101, tex111, t.y);
    float4 tex0 = lerp(tex0_0, tex0_1, t.z);
    float4 tex1 = lerp(tex1_0, tex1_1, t.z);
    return lerp(tex0, tex1, t.x);
}



// kernel0: vel1 -> vel2
[numthreads(8,8, 8)]
void Advection(uint3 id : SV_DispatchThreadID)
{
    // block sphere
    if (distance(float3(id), _BlockSpherePos) < _BlockSphereRadius)
    {
        return;
    }
    float3 vel = _Velocity1.Load(id).xyz;
    float3 pos = float3(id) - vel * _Dt * _AdvectionSpeed;

    _Velocity2[id] = linearInterpolation3D(pos, _Velocity1);
}

// kernel1: vel2 -> vel1
[numthreads(8,8, 8)]
void Diffusion1(uint3 id : SV_DispatchThreadID)
{
    float4 vol = _Velocity2.Load(id);
    float4 left = _Velocity2.Load(id + uint3(-1, 0, 0));
    float4 right = _Velocity2.Load(id + uint3(1, 0, 0));
    float4 top = _Velocity2.Load(id + uint3(0, 1, 0));
    float4 bottom = _Velocity2.Load(id + uint3(0, -1, 0));
    float4 front = _Velocity2.Load(id + uint3(0, 0, 1));
    float4 back = _Velocity2.Load(id + uint3(0, 0, -1));
    float4 bC = vol;

    float alpha = (_Dt / _Viscosity);
    float beta = 4 + alpha;

    _Velocity1[id] = (left + right + top + bottom + front + back + alpha * bC) / beta;
}


// kernel2: vel1 -> vel2
[numthreads(8,8, 8)]
void Diffusion2(uint3 id : SV_DispatchThreadID)
{
    float4 vol = _Velocity1.Load(id);
    float4 left = _Velocity1.Load(id + uint3(-1, 0, 0));
    float4 right = _Velocity1.Load(id + uint3(1, 0, 0));
    float4 top = _Velocity1.Load(id + uint3(0, 1, 0));
    float4 bottom = _Velocity1.Load(id + uint3(0, -1, 0));
    float4 front = _Velocity1.Load(id + uint3(0, 0, 1));
    float4 back = _Velocity1.Load(id + uint3(0, 0, -1));
    float4 bC = vol;

    float alpha = (_Dt / _Viscosity);
    float beta = 4 + alpha;

    _Velocity2[id] = (left + right + top + bottom + front + back + alpha * bC) / beta;
}


// kernel3: vel2 -> vel2
[numthreads(8,8, 8)]
void Force(uint3 id : SV_DispatchThreadID)
{
    float4 vel = _Velocity2.Load(id);
    vel += float4(0, -_Gravity, 0, 0) * _Dt *0.01;
    vel += float4(_ForceDir, 1) * exp(-length(float3(id) - _ForcePos) * 2) * 1;
    _Velocity2[id] = vel;
}


float4 loadVelWithBoundary(float4 bc, int3 pos, RWTexture3D<float4> _Tex)
{
    if (pos.x < 0 || pos.x >= _TexDim.x || pos.y < 0 || pos.y >= _TexDim.y || pos.z < 0 || pos.z >= _TexDim.z)
    {
        return -bc;
    }
    if (distance(float3(pos), _BlockSpherePos) < _BlockSphereRadius)
    {
        return -bc;
    }
    return _Tex.Load(pos);
}



// kernel4: vel2 -> pressure.x
// divergence of velocity
[numthreads(8,8, 8)]
void Divergence(uint3 id : SV_DispatchThreadID)
{
    float4 bc = _Velocity2.Load(id);

    float4 left = loadVelWithBoundary(bc, id + int3(-1, 0, 0), _Velocity2);
    float4 right = loadVelWithBoundary(bc, id + int3(1, 0, 0), _Velocity2);
    float4 top = loadVelWithBoundary(bc, id + int3(0, 1, 0), _Velocity2);
    float4 bottom = loadVelWithBoundary(bc, id + int3(0, -1, 0), _Velocity2);
    float4 front = loadVelWithBoundary(bc, id + int3(0, 0, 1), _Velocity2);
    float4 back = loadVelWithBoundary(bc, id + int3(0, 0, -1), _Velocity2);

    float result = (right.x - left.x + top.y - bottom.y + front.z - back.z) * 0.5;
    _Pressure[id] = float4(0, 0, result, 1);
}

// kernel5: pressure.x -> pressure.y
[numthreads(8,8, 8)]
void Pressure1(uint3 id : SV_DispatchThreadID)
{
    float4 pre = _Pressure.Load(id);
    float left = _Pressure.Load(id + uint3(-1, 0, 0)).x;
    float right = _Pressure.Load(id + uint3(1, 0, 0)).x;
    float top = _Pressure.Load(id + uint3(0, 1, 0)).x;
    float bottom = _Pressure.Load(id + uint3(0, -1, 0)).x;
    float front = _Pressure.Load(id + uint3(0, 0, 1)).x;
    float back = _Pressure.Load(id + uint3(0, 0, -1)).x;

    float bC = pre.z;
    float beta = 6;

    float result = (left + right + top + bottom + front + back - bC) / beta;
    _Pressure[id] = float4(pre.x, result, pre.z, 1);
}


// kernel6: pressure.y -> pressure.x
[numthreads(8,8, 8)]
void Pressure2(uint3 id : SV_DispatchThreadID)
{
    float4 pre = _Pressure.Load(id);
    float left = _Pressure.Load(id + uint3(-1, 0, 0)).y;
    float right = _Pressure.Load(id + uint3(1, 0, 0)).y;
    float top = _Pressure.Load(id + uint3(0, 1, 0)).y;
    float bottom = _Pressure.Load(id + uint3(0, -1, 0)).y;
    float front = _Pressure.Load(id + uint3(0, 0, 1)).y;
    float back = _Pressure.Load(id + uint3(0, 0, -1)).y;

    float bC = pre.z;
    float beta = 6;

    float result = (left + right + top + bottom + front + back - bC) / beta;
    _Pressure[id] = float4(result, pre.y, pre.z, 1);
}

// kernel7: pressure.x & vel2 -> vel1
[numthreads(8,8, 8)]
void Projection(uint3 id : SV_DispatchThreadID)
{
    float4 divergenceVel = _Velocity2.Load(id);

    float left = _Pressure.Load(id + uint3(-1, 0, 0)).x;
    float right = _Pressure.Load(id + uint3(1, 0, 0)).x;
    float top = _Pressure.Load(id + uint3(0, 1, 0)).x;
    float bottom = _Pressure.Load(id + uint3(0, -1, 0)).x;
    float front = _Pressure.Load(id + uint3(0, 0, 1)).x;
    float back = _Pressure.Load(id + uint3(0, 0, -1)).x;

    _Velocity1[id] = divergenceVel - float4(right - left, top - bottom, front - back, 0) * 0.5;
}


// kernel8: clear texture
[numthreads(8,8, 8)]
void ClearTexture(uint3 id : SV_DispatchThreadID)
{
    _Velocity1[id] = float4(0, 0, 0, 1);
    _Velocity2[id] = float4(0, 0, 0, 1);
    _Pressure[id] = float4(0, 0, 0, 1);
    _Density[id] = float4(0, 0, 0, 1);
}

// kernel9: move density
[numthreads(8,8, 8)]
void MoveDensity(uint3 id : SV_DispatchThreadID)
{
    float3 vel = _Velocity1.Load(id).xyz;
    float3 pos = float3(id) - vel * _Dt * _AdvectionSpeed;
    float4 density = linearInterpolation3D(pos, _Density);
    density += _GasColor * exp(-length(float3(id) - _ForcePos));
    _Density[id] = density;
}
